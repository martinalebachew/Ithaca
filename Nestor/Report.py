# Report.py
# (C) Martin Alebachew, 2023
# Nestor â€” RavKav Traffic Analysis Reports [ PROJECT ITHACA ]
from fpdf import FPDF
from Packets import CardToHostPacket
from Packets import HostToCardPacket
from Shared import HEADERS
from Shared import INSTRUCTIONS
from Shared import TABLE_WIDTH
from Shared import VERSION


class Report:

    def __init__(self, date, title, author):
        self.__posY = 0  # Stores the current y pos in document

        # Create a document
        self.__pdf = FPDF()
        self.__pdf.add_page()
        self.__resetFont()
        self.__addInfo(date, title, author)

    def __resetFont(self):
        self.__pdf.set_font("Courier", size=10)
        self.__setFontBlack()

    def __setFontBold(self):
        self.__pdf.set_font("Courier", "B", size=10)

    def __setFontRed(self):
        self.__pdf.set_text_color(220, 40, 40)

    def __setFontBlack(self):
        self.__pdf.set_text_color(0, 0, 0)

    def __addText(self, text, upperPadding=0, fontSize=None):
        if fontSize is not None:
            oldSize = self.__pdf.font_size_pt
            self.__pdf.set_font_size(fontSize)
            self.__addTextInternal(upperPadding, text)
            self.__pdf.set_font_size(oldSize)
        else:
            self.__addTextInternal(upperPadding, text)

    def __addTextInternal(self, upperPadding, text):
        self.__pdf.cell(0, self.__pdf.font_size + upperPadding, txt=text, ln=1)
        # Adding a new cell with the given text, the width is set to 0, meaning that the cell can
        # expand until the right margin. ln is set to 1, which means that the document position pointer
        # will be updated to the next line. The cell height is set to the font size, plus padding after the text.

    def __addInfo(self, date, title, author):
        self.__addText("RavKav Traffic Analysis Report", fontSize=14)
        self.__addText(f"{title}, recorded by {author}\n")
        self.__addText(f"Generated by Nestor {VERSION} on {date}")
        self.__pdf.y += 10  # Add break

    def addRecords(self, parsedPacketsList):
        for parsedPacket in parsedPacketsList:
            self.addRecord(parsedPacket)

    def addRecord(self, parsedPacket):
        if isinstance(parsedPacket, HostToCardPacket):
            self.__addRecordImpl("HostToCard", parsedPacket)
        elif isinstance(parsedPacket, CardToHostPacket):
            self.__addRecordImpl("CardToHost", parsedPacket)
        else:
            raise TypeError("Parsed packet type is unknown!")

    def __addRecordImpl(self, direction, packet):
        with self.__pdf.table(
                first_row_as_headings=True,
                width=TABLE_WIDTH,
                col_widths=HEADERS[direction]["widths"],
        ) as table:
            table.row(HEADERS[direction]["titles"])  # Header row
            table.row([
                packet.serialized[i]
                for i in range(0, len(HEADERS[direction]["titles"]))
            ])  # Data row

        # Notes row
        with self.__pdf.table(first_row_as_headings=False,
                              width=TABLE_WIDTH) as table:
            if direction == "HostToCard":
                if packet.ins in INSTRUCTIONS.keys():
                    table.row(
                        [f"Instruction type: {INSTRUCTIONS[packet.ins]}"])
                else:
                    self.__setFontRed()
                    self.__setFontBold()
                    # Notes row
                    table.row(["Failed to analyse proprietary instruction!"])
                    self.__resetFont()

    def save(self, filepath):
        self.__pdf.output(filepath)


if __name__ == "__main__":
    print("Percentage sum of [in] table widths: ",
          sum(HEADERS["in"]["widths"]), "%")
    print("Percentage sum of [out] table widths: ",
          sum(HEADERS["out"]["widths"]), "%")
    print("Values other than 100% might cause unexpected behavior.")
